Enigma2 BoxInfo Class
=====================

The BoxInfo class is a new system and box information data management 
class.  The configuration data can come from either a system generated 
data file "enigma.info" file or the kernel module.

The new "enigma.info" file is generated by the build system and contains 
exactly the same data as provided by the kernel module.  The new file 
is located as "/usr/lib/enigma.info" and is easier to locate than the 
kernel module whose location varies depending on the kernel in use. 
The contents of the "enigma.info" have a checksum that is verified when 
Enigma2 starts to check the validity / consistency of the file.  This 
file has been made text to simplify its use and has *NOT* been done to 
encourage user editing.  PLEASE DO NOT EDIT THIS FILE!  It is created 
automatically by the build system and maintained by system updates.

The kernel module is a binary kernel module file, called "enigma.ko", 
that exposes the system configuration data as a series of files in the 
system /proc/enigma filesystem.  The file names are the same as the 
variable names in the "enigma.info" file.

The source of the system configuration data depends on each team's 
implementation.  OpenVision began using the kernel module but in a move 
to encourage code sharing has moved to the "enigma.info" file as 
this was seen to be more attractive to other teams.  The method of
access by the Enigma2 Python code is identical.  Python code uses the 
BoxInfo class to access the data.

The BoxInfo class offers six main methods:

getItemsList()

	This method returns a sorted list of all the BoxInfo class variables.

getProcList()

	This method returns a sorted list of all the BoxInfo class variables 
	that are obtained from the system information file.

getEnigmaList()

	This method returns a sorted list of all the BoxInfo class variables 
	that are obtained from the system information override file.

getItem(item, default)

	This method returns the current value of a BoxInfo item.  If the 
	item is not found then the default value is returned.  If no default 
	is provided then a default on None is assumed.

setItem(item, value, immutable)

	This method sets or updates the current value of a BoxInfo item.  The 
	immutable argument is an optional Boolean value that specifies in this 
	item is to be made immutable.  Immutable items can only be created 
	and read.  It can not be updated or deleted.  It is a write once, read 
	many type variable.  NOTE: All the system configuration data items 
	are immutable!  By default all system information variables are 
	mutable by default.  Any mutable variable can be made immutable by 
	setting its value with the immutable argument set to True.

deleteItem(item)

	This method deletes an item from the system.  NOTE: No immutable 
	variables can be deleted!


Enigma Information File
=======================

The Enigma information file is a text file that is created by the image 
build process.  The file is stored in "/usr/lib/enigma.info".  The file is 
a simple text file with lines of "item=value" lines.  The file also contains 
an checksum entry that ensures the file is correct and is as generated.  This 
file must *NOT* be edited.  It is required to remain intact to ensure the 
correct data is available to ensure that Enigma2 can start and operate 
correctly.

To allow for system development an override facility has been built into the 
system.  If the developer / user creates a file "enigma.conf" in the same 
location as "enigma.info" then the values defined in "enigma.info" can be 
overridden for development and testing purposes.  This override file does not 
need to exist and should only exist to allow for specific purposes required 
during code development.  Creating override values that are not correct for 
the hardware in use can make Enigma2 not start or become unstable.

Another use for the "enigma.conf" file is to create new system information 
variables that can be prototyped and tested before being integrated into the 
build process.


Enigma2 Kernel Module
=====================

This module is a replacement for all exisiting hardware checks, it replaces 
boxbranding, enigma2 internal methods like getBoxType().  This feature is 
implemented via SystemInfo.  This is intended to be a single entry point 
for accessing and managing all hardware and system data.

This data is accessed and managed via the BoxInfo class within SystemInfo.py. 
Unlike the SystemInfo dictionary the data is contained and isolated within 
the SystemInfo module.  There is no need to export or share the dictionary 
across Enigma2 modules.

Enigma2 internal calls need enigma2 to be running first so can't be used 
outside of Enigma2 and boxbranding works if you import it so not a good 
solution for shell scripts and anything other than Python.

Enigma2 kernel module is a pre-compiled .ko file which contains needed 
information about hardware features, as it's a compiled file it's secure 
and can't be changed later.  The module creates many proc files which 
could be read with any language.  If the module is not currently loaded, 
like in a multiboot situation, we read the module description instead 
of relying on the proc files so "modinfo -d" will help us.

Current enigma2 reads the module via SystemInfo.py and current proc path 
is "/proc/enigma" and the module name is "enigma.ko" which could be changed 
if all teams agree on something.


System Information Variables
============================
The first thing to note is that which ever mechanism, defined above, is 
used in an image to deliver the system information data the item variables 
should always remain consistant.  If a variable is used in "enigma.info" 
then that same item name *MUST* be the same and provide *EXACTLY* the same 
information in the kernel module.

The system variables defined here are based on OE-Alliance's sources but has 
some items added and some removed.  For consistency with "/proc/enigma" file 
name expectations many of the variable names are different from those defined 
in the OE-Alliance "boxbranding" code.  The following list provides mapping 
to the original "boxbranding" method calls as appropriate.

Here is the list of variables currently supported:

	"model" or "/proc/enigma/model" replaces "getBoxType()"
		("getMachineName()" and "getMachineMake()" in OE-Alliance's "boxbranding")
	"displaymodel" or "/proc/enigma/displaymodel" replaces "getDisplayModel()"
	"brand" or "/proc/enigma/brand" replaces "getBoxBrand()"
		("getMachineBrand() and "getBrandOEM()" in OE-Alliance's "boxbranding")
	"displaybrand" or "/proc/enigma/displaybrand" replaces "getDisplayBrand()"
	"platform" or "/proc/enigma/platform" replaces "getMachineBuild()"
	"imgversion" or "/proc/enigma/imgversion" replaces "getIMGVersion()"
	"imgrevision" or "/proc/enigma/imgrevision" replaces "getIMGRevision()"
	"imglanguage" or "/proc/enigma/imglanguage" replaces "getIMGLanguage()
	"developername" or "/proc/enigma/developername" replaces "getDeveloperName()"
	"feedsurl" or "/proc/enigma/feedsurl" replaces "getFeedsUrl()"
	"distro" or "/proc/enigma/distro" replaces "getImageDistro()"
	"displaydistro" or "/proc/enigma/displaydistro" replaces "getDisplayDistro()"
	"oe" or "/proc/enigma/oe" replaces "getOEVersion()"
	"kernel" or "/proc/enigma/kernel" replaces "getKernelVersion()"
	"python" or "/proc/enigma/python"
	"mediaservice" or "/proc/enigma/mediaservice" replaces "getE2Service()"
	"multilib" or "/proc/enigma/multilib" replaces "getHaveMultiLib()"
	"architecture" or "/proc/enigma/architecture" replaces "getImageArch()"
	"socfamily" or "/proc/enigma/socfamily" replaces "getSoCFamily()"
	"blindscanbinary" or "/proc/enigma/blindscanbinary" replaces "getBlindscanBin()"
	"rctype" or "/proc/enigma/rctype" replaces "getRCType()"
	"rcname" or "/proc/enigma/rcname" repalces "getRCName()"
	"rcidnum" or "/proc/enigma/rcidnum" replaces "getRCIDNum()"
	"smallflash" or "/proc/enigma/smallflash" replaces "getHaveSmallFlash()"
	"middleflash" or "/proc/enigma/middleflash" replaces "getHaveMiddleFlash()"
	"imagedir" or "/proc/enigma/imagedir" replaces "getImageFolder()"
	"imagefs" or "/proc/enigma/imagefs" replaces "getImageFileSystem()"
	"mtdbootfs" or "/proc/enigma/mtdbootfs" replaces "getMachineMtdBoot()"
	"mtdrootfs" or "/proc/enigma/mtdrootfs" replaces "getMachineMtdRoot()"
	"mtdkernel" or "/proc/enigma/mtdkernel" replaces "getMachineMtdKernel()"
	"rootfile" or "/proc/enigma/rootfile" repalces "getMachineRootFile()"
	"kernelfile" or "/proc/enigma/kernelfile" replaces "getMachineKernelFile()"
	"mkubifs" or "/proc/enigma/mkubifs" replaces "getMachineMKUBIFS()"
	"ubinize" or "/proc/enigma/ubinize" replaces "getMachineUBINIZE()"
	"forcemode" or "/proc/enigma/forcemode" replaces "getForceMode()"
	"compiledate" or "/proc/enigma/compiledate"
	"fpu" or "/proc/enigma/fpu" replaces "getImageFPU()"
	"displaytype" or "/proc/enigma/displaytype" replaces "getDisplayType()"
	"transcoding" or "/proc/enigma/transcoding" replaces "getHaveTranscoding()"
		("getHaveTranscoding1()" in OE-Alliance's "boxbranding")
	"multitranscoding" or "/proc/enigma/multitranscoding" replaces "getHaveMultiTranscoding()"
		("getHaveTranscoding2()" in OE-Alliance's "boxbranding")
	"hdmi" or "/proc/enigma/hdmi" replaces "getHaveHDMI()"
	"yuv" or "/proc/enigma/yuv" replaces "getHaveYUV()"
	"rca" or "/proc/enigma/rca" replaces "getHaveRCA()"
	"avjack" or "/proc/enigma/avjack" replaces "getHaveAVJACK()"
	"scart" or "/proc/enigma/scart" replaces "getHaveSCART()"
	"dvi" or "/proc/enigma/dvi" replaces "getHaveDVI()"
	"svideo" or "/proc/enigma/svideo" replaces "getHaveSVIDEO()"
	"hdmihdin" or "/proc/enigma/hdmihdin" replaces "getHaveHDMIinHD()"
	"hdmifhdin" or "/proc/enigma/hdmifhdin" replaces "getHaveHDMIinFHD()"
	"wol" or "/proc/enigma/wol" replaces "getHaveWOL()"
		(Also "getHaveWWOL()" in OE-Alliance's "boxbranding" as we don't split Wake-on-LAN and Wake-on-WLAN)
	"ci" or "/proc/enigma/ci" replaces "getHaveCI()"
	"vfdsymbol" or "/proc/enigma/vfdsymbol" replaces "getHaveVFDSymbol()"
	"fhdskin" or "/proc/enigma/fhdskin" replaces "getFHDSkin()"
	"dboxlcd" or "/proc/enigma/dboxlcd" replaces "getDBoxLCD()"
	"imageversion" or "/proc/enigma/imageversion" replaces "getImageVersion()"
	"imagebuild" or "/proc/enigma/imagebuild" replaces "getImageBuild()"
	"imagedevbuild" or "/proc/enigma/imagedevbuild" replaces "getImageDevBuild()"
	"imagetype" or "/proc/enigma/imagetype" replaces "getImageType()"
	"/proc/enigma/informations" which has all above information in one proc file.
		NOTE: There is no "enigma.info" version of this item!

* Replacement for getMachineProcModel is getBoxProc in StbHardware.py
* Replacement for OE-Alliance's boxbranding getDriverDate is getDriverInstalledDate in About.py (Components)
* Replacement for OE-Alliance's boxbranding getHaveMiniTV is LCDMiniTV in SystemInfo.py
* We don't have anything for OE-A's boxbranding getHaveSCARTYUV and we manage it via if conditions in VideoHardware.py

Time to explain each one and give examples:

model:

	BoxInfo.getItem("model") (/proc/enigma/model)

		This variable defines the receiver model in OE sources.

		Real model could be a different thing in real life and this is 
		only what kernel defconfig shows as hostname.

	Example: h9

displaymodel:

	BoxInfo.getItem("displaymodel") (/proc/enigma/displaymodel)

		This variable defines the receiver real model in real life.

		Real model is what printed on the receiver.

	Example: H9T

brand:

	BoxInfo.getItem("brand") (/proc/enigma/brand)

		This variable defines the receiver brand or the meta name in OE sources.

		Real brand could be a different thing in real life, also not all the 
		times it's the brand name but sometimes it's the meta name so it's 
		related to OE sources.

	Example: airdigital

displaybrand:

	BoxInfo.getItem("displaybrand") (/proc/enigma/displaybrand)

		This variable defines the receiver real brand in real life.

		Real brand is what printed on the receiver.

	Example: Zgemma

platform:

	BoxInfo.getItem("platform") (/proc/enigma/platform)

		This variable defines the receiver platform in OE sources.

		This is not a real thing, it's what developers call a family of 
		similar hardwares.  Instead of checking models one by one we 
		could assing something to a family and reduce the checks.
		If a model does not belong to a family the platform will be 
		same as model so model and platform are equal in some receivers.

	Example: zgemmahisi3798mv200

imgversion:

	BoxInfo.getItem("imgversion") (/proc/enigma/imgversion)

		This variable defines the main image version which only changes when 
		GCC changes or when other important packages like python get updated.

	Example: 10.3

imgrevision:

	BoxInfo.getItem("imgrevision") (/proc/enigma/imgrevision)

		This variable defines the image revision which changes after a batch of changes.

	Example: r396

imglanguage:

	BoxInfo.getItem("imglanguage") (/proc/enigma/imglanguage)

		This variable defines the language set which could be english, multilanguage 
		or extralanguage (which has all) depending on the flash size.

		multilanguage has ar, de, es, it, ru and tr locales.

	Example: extralanguage

developername:

	BoxInfo.getItem("developername") (/proc/enigma/developername)

		This variable defines who compiled the image which could be a real developer 
		or just a certified compiler, some image compilers add/remove things and with 
		this variable we know which one has what packages.

	Example: persianpros

feedsurl:

	BoxInfo.getItem("feedsurl") (/proc/enigma/feedsurl)

		This variable defines the main feed URL for opkg.

	Example: https://feeds.openenigma.org

distro:

	BoxInfo.getItem("distro") (/proc/enigma/distro)

		This variable defines the image distro.

		Mostly we use this for multiboot tools.

	Example: openvision

displaydistro:

	BoxInfo.getItem("displaydistro") (/proc/enigma/displaydistro)

		This variable shows the friendly distro name.

		Mostly we use this for information pages.

	Example: Open Vision

oe:

	BoxInfo.getItem("oe") (/proc/enigma/oe)

		This variable defines the OE branch.

		If it's anything other than "master" means it's fixed on a specific branch 
		like pyro and there will be no more updates from main OE and requires only 
		monthly maintenance to keep it up-to-date with other sources.

	Example: master

kernel:

	BoxInfo.getItem("kernel") (/proc/enigma/kernel)

		This variable defines the kernel version.

		Let us know what version of the kernel a receiver has so what features 
		are compatible.

	Example: 4.4.35

python:

	BoxInfo.getItem("python") (/proc/enigma/python)

		This variable defines the python exact version.

	Example: 2.7.18

mediaservice:

	BoxInfo.getItem("mediaservice") (/proc/enigma/mediaservice)

		This variable defines the enigma2 media service.

	Example: enigma2-plugin-systemplugins-servicehisilicon

multilib:

	BoxInfo.getItem("multilib") (/proc/enigma/multilib)

		This variable defines the multilib situation.

		It can only be True if an image has aarch64 architecture and lib64 
		is available in the root directory.

	Example: False

architecture:

	BoxInfo.getItem("architecture") (/proc/enigma/architecture)

		This variable defines the main architecture of the image.

		Useful when we want to know what kind of ipk files we can install 
		on a receiver via opkg or what type of binary files we could run.

	Example: cortexa15hf-neon-vfpv4

socfamily:

	BoxInfo.getItem("socfamily") (/proc/enigma/socfamily)

		This variable defines the SoC type.

		Some settings could be applied per SoC as they're CPU dependent.

	Example: hisi3798mv200

blindscanbinary:

	BoxInfo.getItem("blindscanbinary") (/proc/enigma/blindscanbinary)

		This variable defines the blindscan binary file name.

		We use this for blindscan tools.

	Example: blindscan

rctype:

	BoxInfo.getItem("rctype") (/proc/enigma/rctype)

		This variable defines the remote control type.

	Example: 28

rcname:

	BoxInfo.getItem("rcname") (/proc/enigma/rcname)

		This variable defines the remote control name which we use for XML and 
		PNG files.

	Example: zgemma6

rcidnum:

	BoxInfo.getItem("rcidnum") (/proc/enigma/rcidnum)

		This variable defines the remote control ID number.

		In remote control XML files we have a line like <rc id="2"> which 
		define what ID number could be used.

	Example: 2

smallflash:

	BoxInfo.getItem("smallflash") (/proc/enigma/smallflash)

		This variable defines the flash size and if it's equal to 64MB 
		or less than that.

		We use this to compile compatible images for small flash receivers.

	Example: False

middleflash:

	BoxInfo.getItem("middleflash") (/proc/enigma/middleflash)

		This variable defines the flash size and if it's equal to 128MB or 
		less but more than 64MB.

		Even some receivers with 128MB flashes can not flash or boot images 
		more than 96MB because of a limit in their CFE.

		We use this to compile compatible images for middle flash receivers.

	Example: False

imagedir:

	BoxInfo.getItem("imagedir") (/proc/enigma/imagedir)

		This variable defines the image directory for a receiver and how the 
		structure of the zip file should be.

		Mostly we use this for backup tools.

	Example: h9

imagefs:

	BoxInfo.getItem("imagefs") (/proc/enigma/imagefs)

		This variable defines the image filesystem for a receiver which can boot.

		Mostly we use this for backup tools.

	Example: ubi (sometimes there's a space at the beginning of this variable which should be avoided)

mtdbootfs:

	BoxInfo.getItem("mtdbootfs") (/proc/enigma/mtdbootfs)

		This variable defines the boot filesystem mtd number of an image.

		Mostly we use this for backup/multiboot tools.

	Example: mmcblk0p4 (for h9 this is empty and I just wrote an example)

mtdrootfs:

	BoxInfo.getItem("mtdrootfs") (/proc/enigma/mtdrootfs)

		This variable defines the root filesystem mtd number of an image.

		Mostly we use this for backup/multiboot tools.

	Example: mtd7

mtdkernel:

	BoxInfo.getItem("mtdkernel") (/proc/enigma/mtdkernel)

		This variable defines the kernel mtd number of an image.

		Mostly we use this for backup/multiboot tools.

	Example: mtd6

rootfile:

	BoxInfo.getItem("rootfile") (/proc/enigma/rootfile)

		This variable defines the root file name of an image.

		Mostly we use this for backup/multiboot tools.

	Example: rootfs.ubi

kernelfile:

	BoxInfo.getItem("kernelfile") (/proc/enigma/kernelfile)

		This variable defines the kernel file name of an image.

		Mostly we use this for backup tools.

	Example: uImage

mkubifs:

	BoxInfo.getItem("mkubifs") (/proc/enigma/mkubifs)

		This variable defines the mkubifs command parameters.

		Mostly we use this for backup tools when want to repack the image.

	Example: -m 2048 -e 126976 -c 8192

ubinize:

	BoxInfo.getItem("ubinize") (/proc/enigma/ubinize)

		This variable defines the ubinize command parameters.

		Mostly we use this for backup tools when want to repack the image.

	Example: -m 2048 -p 128KiB

forcemode:

	BoxInfo.getItem("forcemode") (/proc/enigma/forcemode)

		This variable defines the force mode of the zip file.

		Some receivers won't flash without enabling the force mode.

		Mostly we use this for backup tools.

	Example: no

compiledate:

	BoxInfo.getItem("compiledate") (/proc/enigma/compiledate)

		This variable defines the compile date of the enigma.ko file.

	Example: 20210524

fpu:

	BoxInfo.getItem("fpu") (/proc/enigma/fpu)

		This variable defines the fpu type which is the float type of 
		the architecure and it's CPU dependent.

	Example: hard

displaytype:

	BoxInfo.getItem("displaytype") (/proc/enigma/displaytype)

		This variable defines the front display type of a receiver.

	Example: colorlcd400 (for h9 this is empty and I just wrote an example)

transcoding:

	BoxInfo.getItem("transcoding") (/proc/enigma/transcoding)

		This variable defines if a receiver supports transcoding feature.

	Example: False

multitranscoding:

	BoxInfo.getItem("multitranscoding") (/proc/enigma/multitranscoding)

		This variable defines if a receiver supports multi transcoding feature.

	Example: True

hdmi:

	BoxInfo.getItem("hdmi") (/proc/enigma/hdmi)

		This variable defines if a receiver has HDMI output.

	Example: True

yuv:

	BoxInfo.getItem("yuv") (/proc/enigma/yuv)

		This variable defines if a receiver has YUV output.

	Example: False

rca:

	BoxInfo.getItem("rca") (/proc/enigma/rca)

		This variable defines if a receiver has RCA output.

	Example: False

avjack:

	BoxInfo.getItem("avjack") (/proc/enigma/avjack)

		This variable defines if a receiver has AV Jack output.

	Example: False

scart:

	BoxInfo.getItem("scart") (/proc/enigma/scart)

		This variable defines if a receiver has SCART output.

	Example: False

dvi:

	BoxInfo.getItem("dvi") (/proc/enigma/dvi)

		This variable defines if a receiver has DVI output.

	Example: False

svideo:

	BoxInfo.getItem("svideo") (/proc/enigma/svideo)

		This variable defines if a receiver has S-Video output.

	Example: False

hdmihdin:

	BoxInfo.getItem("hdmihdin") (/proc/enigma/hdmihdin)

		This variable defines if a receiver has HDMI-In input.

	Example: False

hdmifhdin:

	BoxInfo.getItem("hdmifhdin") (/proc/enigma/hdmifhdin)

		This variable defines if a receiver has HDMI-In (Full HD) input.

	Example: False

wol:

	BoxInfo.getItem("wol") (/proc/enigma/wol)

		This variable defines if a receiver supports Wake-on-LAN/WLAN feature.

	Example: True

ci:

	BoxInfo.getItem("ci") (/proc/enigma/ci)

		This variable defines if a receiver has DVB Common Interface slot.

	Example: True

vfdsymbol:

	BoxInfo.getItem("vfdsymbol") (/proc/enigma/vfdsymbol)

		This variable defines if a receiver supports VFD symbol feature.

		It also depends on the display type.

	Example: False

fhdskin:

	BoxInfo.getItem("fhdskin") (/proc/enigma/fhdskin)

		This variable defines if a receiver supports Full HD skins.

	Example: True

dboxlcd:

	BoxInfo.getItem("dboxlcd") (/proc/enigma/dboxlcd)

		This variable defines if a receiver supports eDBoxLCD enigma2 feature.

	Example: True

imageversion:

	BoxInfo.getItem("imageversion") (/proc/enigma/imageversion)

		This variable defines the image version.

		Mostly we use this for backup tools and compatibility with other images.

	Example: develop

imagebuild:

	BoxInfo.getItem("imagebuild") (/proc/enigma/imagebuild)

		This variable defines the image build.

		Mostly we use this for backup tools and compatibility with other images.

	Example: master

imagedevbuild:

	BoxInfo.getItem("imagedevbuild") (/proc/enigma/imagedevbuild)

		This variable defines the image developer build.

		Mostly we use this for backup tools and compatibility with other images.

	Example: new

imagetype:

	BoxInfo.getItem("imagetype") (/proc/enigma/imagetype)

		This variable defines the image type.

		Mostly we use this for backup tools and compatibility with other images.

	Example: release

informations:

	BoxInfo.getItem("informations") (/proc/enigma/informations)

		This variable includes all enigma proc informations in one file.

	Example: All above examples in one file

(Remember: All "enigma.info" and "/proc/enigma" files and modinfo data are immutable.)
